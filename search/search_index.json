{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django-Flags \u00b6 Feature flags allow you to toggle functionality in both Django code and the Django templates based on configurable conditions. Flags can be useful for staging feature deployments, for A/B testing, or for any time you need an on/off switch for blocks of code. The toggle can be by date, user, URL value, or a number of other conditions , editable in the admin or in definable in settings. Dependencies \u00b6 Django 2.2, 3.0, 4.x Python 3.7+ Installation \u00b6 First, install django-flags: pip install django-flags Then add flags as an installed app in your Django settings.py : INSTALLED_APPS = ( # \u2026 'flags', # \u2026 ) And django.template.context_processors.request to the TEMPLATES context_processors setting so that the request variable is available: TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', # \u2026 'OPTIONS': { # \u2026 'context_processors': [ # \u2026 'django.template.context_processors.request', # \u2026 ], # \u2026 }, # \u2026 }, ] Finally, run migrations: ./manage.py migrate Concepts \u00b6 Feature flags in Django-Flags are identified by simple strings that are enabled when the conditions they are associated with are met. These flags can be used to wrap code and template content that should only be used when a flag is enabled or disabled. Conditions determine whether a flag is enabled or disabled by comparing a defined expected value of some kind with the value at the time the flag is checked. In many cases, the flag is checked during a request, and some piece of the request's metadata is what is compared. For example, a feature flag that is enabled for a specific user would be enabled if the request's user matches the condition's user. Quickstart \u00b6 To use Django-Flags you first need to define the flag, use the flag, and define conditions for the flag to be enabled. First, define the flag in Django settings.py : FLAGS = { 'MY_FLAG': [] } Then use the flag in a Django template ( mytemplate.html ): {% load feature_flags %} {% flag_enabled 'MY_FLAG' as my_flag %} {% if my_flag %} <div class=\"flagged-banner\"> I\u2019m the result of a feature flag. </div> {% endif %} Configure a URL for that template ( urls.py ): from django.urls import path from django.views.generic import TemplateView urlpatterns = [ path(r'mypage/', TemplateView.as_view(template_name='mytemplate.html')), ] Then in the Django admin add conditions for the flag in \"Django Flags\", \"Flag states\": Then visiting the URL /mypage?enable_my_flag=True should show you the flagged <div> in the template.","title":"Getting started"},{"location":"#django-flags","text":"Feature flags allow you to toggle functionality in both Django code and the Django templates based on configurable conditions. Flags can be useful for staging feature deployments, for A/B testing, or for any time you need an on/off switch for blocks of code. The toggle can be by date, user, URL value, or a number of other conditions , editable in the admin or in definable in settings.","title":"Django-Flags"},{"location":"#dependencies","text":"Django 2.2, 3.0, 4.x Python 3.7+","title":"Dependencies"},{"location":"#installation","text":"First, install django-flags: pip install django-flags Then add flags as an installed app in your Django settings.py : INSTALLED_APPS = ( # \u2026 'flags', # \u2026 ) And django.template.context_processors.request to the TEMPLATES context_processors setting so that the request variable is available: TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', # \u2026 'OPTIONS': { # \u2026 'context_processors': [ # \u2026 'django.template.context_processors.request', # \u2026 ], # \u2026 }, # \u2026 }, ] Finally, run migrations: ./manage.py migrate","title":"Installation"},{"location":"#concepts","text":"Feature flags in Django-Flags are identified by simple strings that are enabled when the conditions they are associated with are met. These flags can be used to wrap code and template content that should only be used when a flag is enabled or disabled. Conditions determine whether a flag is enabled or disabled by comparing a defined expected value of some kind with the value at the time the flag is checked. In many cases, the flag is checked during a request, and some piece of the request's metadata is what is compared. For example, a feature flag that is enabled for a specific user would be enabled if the request's user matches the condition's user.","title":"Concepts"},{"location":"#quickstart","text":"To use Django-Flags you first need to define the flag, use the flag, and define conditions for the flag to be enabled. First, define the flag in Django settings.py : FLAGS = { 'MY_FLAG': [] } Then use the flag in a Django template ( mytemplate.html ): {% load feature_flags %} {% flag_enabled 'MY_FLAG' as my_flag %} {% if my_flag %} <div class=\"flagged-banner\"> I\u2019m the result of a feature flag. </div> {% endif %} Configure a URL for that template ( urls.py ): from django.urls import path from django.views.generic import TemplateView urlpatterns = [ path(r'mypage/', TemplateView.as_view(template_name='mytemplate.html')), ] Then in the Django admin add conditions for the flag in \"Django Flags\", \"Flag states\": Then visiting the URL /mypage?enable_my_flag=True should show you the flagged <div> in the template.","title":"Quickstart"},{"location":"conditions/","text":"Conditions \u00b6 Built-in conditions \u00b6 Django-Flags comes with the following conditions built-in: boolean \u00b6 A simple boolean true/false intended to enable or disable a flag explicitly. The state of the flag evaluates to the value of the boolean condition. FLAGS = {'MY_FLAG': [{'condition': 'boolean', 'value': True}]} The value can given as a Python True or False or as any string representation of truth , such as y , yes , t , true , on and 1 for true values, and n , no , f , false , off and 0 for false values. user \u00b6 Allows a flag to be enabled for the username given as the condition's value. FLAGS = {'MY_FLAG': [{'condition': 'user', 'value': 'jane.doe'}]} anonymous \u00b6 Allows a flag to be either enabled or disabled depending on whether a user is anonymous (not logged in) to Django. # MY_FLAG is enabled if the user is not anonymous (is logged in) FLAGS = {'MY_FLAG': [{'condition': 'anonymous', 'value': False}]} The value can given as a Python True or False or as any string representation of truth , such as y , yes , t , true , on and 1 for true values, and n , no , f , false , off and 0 for false values. parameter \u00b6 Allows a flag to be enabled by including a parameter in the request's query string. value is the name of the parameter, or a name and expected value. If an expected value isn't provided, the value must be True . FLAGS = { 'MY_FLAG': [ {'condition': 'parameter', 'value': 'my_flag_param1'}, # ?my_flag_param1=True {'condition': 'parameter', 'value': 'my_flag_param2=now'}, # ?my_flag_param2=now {'condition': 'parameter', 'value': 'my_flag_param3='}, # ?my_flag_param3 ] } path matches \u00b6 Allows a flag to be enabled if the request's path matches the regular expression value. FLAGS = {'MY_FLAG': [{'condition': 'path matches', 'value': r'^/flagged/path'}]} after date \u00b6 Allows a flag to be enabled after a given date (and time) given in ISO 8601 format . The time must be specified either in UTC or as an offset from UTC. FLAGS = {'MY_FLAG': [{'condition': 'after date', 'value': '2017-06-01T12:00Z'}]} before_date \u00b6 Allows a flag to be enabled before a given date (and time) given in ISO 8601 format . The time must be specified either in UTC or as an offset from UTC. FLAGS = {'MY_FLAG': {'before date': '2022-06-01T12:00Z'}} Custom conditions \u00b6 Custom conditions can be created and registered for use using the conditions API .","title":"Conditions"},{"location":"conditions/#conditions","text":"","title":"Conditions"},{"location":"conditions/#built-in-conditions","text":"Django-Flags comes with the following conditions built-in:","title":"Built-in conditions"},{"location":"conditions/#boolean","text":"A simple boolean true/false intended to enable or disable a flag explicitly. The state of the flag evaluates to the value of the boolean condition. FLAGS = {'MY_FLAG': [{'condition': 'boolean', 'value': True}]} The value can given as a Python True or False or as any string representation of truth , such as y , yes , t , true , on and 1 for true values, and n , no , f , false , off and 0 for false values.","title":"boolean"},{"location":"conditions/#user","text":"Allows a flag to be enabled for the username given as the condition's value. FLAGS = {'MY_FLAG': [{'condition': 'user', 'value': 'jane.doe'}]}","title":"user"},{"location":"conditions/#anonymous","text":"Allows a flag to be either enabled or disabled depending on whether a user is anonymous (not logged in) to Django. # MY_FLAG is enabled if the user is not anonymous (is logged in) FLAGS = {'MY_FLAG': [{'condition': 'anonymous', 'value': False}]} The value can given as a Python True or False or as any string representation of truth , such as y , yes , t , true , on and 1 for true values, and n , no , f , false , off and 0 for false values.","title":"anonymous"},{"location":"conditions/#parameter","text":"Allows a flag to be enabled by including a parameter in the request's query string. value is the name of the parameter, or a name and expected value. If an expected value isn't provided, the value must be True . FLAGS = { 'MY_FLAG': [ {'condition': 'parameter', 'value': 'my_flag_param1'}, # ?my_flag_param1=True {'condition': 'parameter', 'value': 'my_flag_param2=now'}, # ?my_flag_param2=now {'condition': 'parameter', 'value': 'my_flag_param3='}, # ?my_flag_param3 ] }","title":"parameter"},{"location":"conditions/#path-matches","text":"Allows a flag to be enabled if the request's path matches the regular expression value. FLAGS = {'MY_FLAG': [{'condition': 'path matches', 'value': r'^/flagged/path'}]}","title":"path matches"},{"location":"conditions/#after-date","text":"Allows a flag to be enabled after a given date (and time) given in ISO 8601 format . The time must be specified either in UTC or as an offset from UTC. FLAGS = {'MY_FLAG': [{'condition': 'after date', 'value': '2017-06-01T12:00Z'}]}","title":"after date"},{"location":"conditions/#before_date","text":"Allows a flag to be enabled before a given date (and time) given in ISO 8601 format . The time must be specified either in UTC or as an offset from UTC. FLAGS = {'MY_FLAG': {'before date': '2022-06-01T12:00Z'}}","title":"before_date"},{"location":"conditions/#custom-conditions","text":"Custom conditions can be created and registered for use using the conditions API .","title":"Custom conditions"},{"location":"debugging/","text":"Debugging \u00b6 System checks \u00b6 `flags.E001` Django-Flags includes a Django system check to check for flags that have non-existent conditions on start-up. ?: (flags.E001) Flag FLAG_WITH_ANY_CONDITIONS has non-existent condition \"condition name\". HINT: Register \"condition name\" as a Django-Flags condition. `flags.E002` Django-Flags includes a Django system check to check to ensure that flag conditions have valid expected values on start-up. ?: (flags.E002) Flag FLAG_WITH_ANY_CONDITIONS's \"boolean\" condition has an invalid value. HINT: Enter one of \"on\", \"off\", \"true\", \"false\". Exceptions \u00b6 RequiredForCondition \u00b6 Django-Flags allows conditions to require any number of keyword arguments that must be passed when checking the condition. If a condition does not receive the necessary arguments, it may raise a RequiredForCondition exception, for example: Traceback (most recent call last): \u2026 raise RequiredForCondition(\"request is required for condition 'path'\") Django Debug Toolbar Panels \u00b6 Flag conditions \u00b6 Django-Flags comes with a panel for Django Debug Toolbar that will list all flags, their conditions, and the state of each flag for the current request. To enable the panel first follow the installation and setup instructions for Django Debug Toolbar . Then add flags.panels.FlagsPanel to the DEBUG_TOOLBAR_PANELS setting: DEBUG_TOOLBAR_PANELS = [ # \u2026 'flags.panels.FlagsPanel', # \u2026 ] Flag checks \u00b6 Django-Flags comes with a panel for Django Debug Toolbar that will show which flags were checked during a request, how many times it was checked, and what the results of those checks were. To enable the panel first follow the installation and setup instructions for Django Debug Toolbar . Then add flags.panels.FlagChecksPanel to the DEBUG_TOOLBAR_PANELS setting: DEBUG_TOOLBAR_PANELS = [ # \u2026 'flags.panels.FlagChecksPanel', # \u2026 ]","title":"Debugging"},{"location":"debugging/#debugging","text":"","title":"Debugging"},{"location":"debugging/#system-checks","text":"`flags.E001` Django-Flags includes a Django system check to check for flags that have non-existent conditions on start-up. ?: (flags.E001) Flag FLAG_WITH_ANY_CONDITIONS has non-existent condition \"condition name\". HINT: Register \"condition name\" as a Django-Flags condition. `flags.E002` Django-Flags includes a Django system check to check to ensure that flag conditions have valid expected values on start-up. ?: (flags.E002) Flag FLAG_WITH_ANY_CONDITIONS's \"boolean\" condition has an invalid value. HINT: Enter one of \"on\", \"off\", \"true\", \"false\".","title":"System checks"},{"location":"debugging/#exceptions","text":"","title":"Exceptions"},{"location":"debugging/#requiredforcondition","text":"Django-Flags allows conditions to require any number of keyword arguments that must be passed when checking the condition. If a condition does not receive the necessary arguments, it may raise a RequiredForCondition exception, for example: Traceback (most recent call last): \u2026 raise RequiredForCondition(\"request is required for condition 'path'\")","title":"RequiredForCondition"},{"location":"debugging/#django-debug-toolbar-panels","text":"","title":"Django Debug Toolbar Panels"},{"location":"debugging/#flag-conditions","text":"Django-Flags comes with a panel for Django Debug Toolbar that will list all flags, their conditions, and the state of each flag for the current request. To enable the panel first follow the installation and setup instructions for Django Debug Toolbar . Then add flags.panels.FlagsPanel to the DEBUG_TOOLBAR_PANELS setting: DEBUG_TOOLBAR_PANELS = [ # \u2026 'flags.panels.FlagsPanel', # \u2026 ]","title":"Flag conditions"},{"location":"debugging/#flag-checks","text":"Django-Flags comes with a panel for Django Debug Toolbar that will show which flags were checked during a request, how many times it was checked, and what the results of those checks were. To enable the panel first follow the installation and setup instructions for Django Debug Toolbar . Then add flags.panels.FlagChecksPanel to the DEBUG_TOOLBAR_PANELS setting: DEBUG_TOOLBAR_PANELS = [ # \u2026 'flags.panels.FlagChecksPanel', # \u2026 ]","title":"Flag checks"},{"location":"management_commands/","text":"Management Commands \u00b6 Django-Flags provides two management commands that allow for enabling and disabling of feature flags from the command line. enable_flag FLAG_NAME \u00b6 Enable a flag by adding or setting an existing database boolean condition to True . If the flag has other required conditions, those will take precedence. This command calls the flags.state.enable_flag function function. ./manage.py enable_flag MY_FLAG disable_flag FLAG_NAME \u00b6 Disable a flag by adding or setting an existing database boolean condition to False . If the flag has other required conditions, those will take precedence. This command calls the flags.state.enable_flag function function. ./manage.py disable_flag MY_FLAG","title":"Management commands"},{"location":"management_commands/#management-commands","text":"Django-Flags provides two management commands that allow for enabling and disabling of feature flags from the command line.","title":"Management Commands"},{"location":"management_commands/#enable_flag-flag_name","text":"Enable a flag by adding or setting an existing database boolean condition to True . If the flag has other required conditions, those will take precedence. This command calls the flags.state.enable_flag function function. ./manage.py enable_flag MY_FLAG","title":"enable_flag FLAG_NAME"},{"location":"management_commands/#disable_flag-flag_name","text":"Disable a flag by adding or setting an existing database boolean condition to False . If the flag has other required conditions, those will take precedence. This command calls the flags.state.enable_flag function function. ./manage.py disable_flag MY_FLAG","title":"disable_flag FLAG_NAME"},{"location":"releasenotes/","text":"Release Notes \u00b6 5.1.0 \u00b6 What's new? \u00b6 Added support for Python 3.13, removed support for Python < 3.10 5.0.14 \u00b6 What's new? \u00b6 Updated packaging to pyproject.toml and linting/formatting to ruff Added Django 5.0 support (thanks @adamchainz !) Added Django 5.2 support (thanks @sergei-maertens !) Bug fixes \u00b6 Fixed parameter condition example in docs (thanks @andy-isoc !) 5.0.13 \u00b6 What's new? \u00b6 Modernize code for Python 3.6+ (thanks @adamchainz !) Run linters with Python 3.11 (thanks @adamchainz !) Format with Black 23 (thanks @adamchainz !) Added Django 4.2 support (thanks @adamchainz !). Removals \u00b6 Removed Python 3.6 support (thanks @michael-k !). Bug fixes \u00b6 Removed errant print statement (thanks @Natim !). 5.0.12 \u00b6 What's new? \u00b6 Added Django 4.1 support (thanks @adamchainz !). 5.0.11 \u00b6 What's new? \u00b6 Added changelog and documentation links to the package on PyPI (thanks @adamchainz !) 5.0.10 \u00b6 What's new? \u00b6 Fixed an issue with resolving include() s in flagged_path() URL patterns ( #100 ) 5.0.9 \u00b6 What's new? \u00b6 Fixed a DeprecationWarning on Jinja 3+. Fixed an AttributeError on AnonymousUser in the user condition (thanks @edomora97 !) 5.0.8 \u00b6 What's new? \u00b6 Prevent RemovedInDjango41Warning about default_app_config for Django 3.2+ (thanks @adamchainz !) 5.0.7 \u00b6 What's new? \u00b6 Update Django 4 pin to allow versions under 4.1 5.0.6 \u00b6 What's new? \u00b6 Added Django 4.0 support (thanks @gregtap !) 5.0.5 \u00b6 What's new? \u00b6 Added Django 3.2 support (thanks @dduong42 !) 5.0.4 \u00b6 What's new? \u00b6 Fixed the \"path matches\" condition validator to allow any valid regular expression. 5.0.3 \u00b6 What's new? \u00b6 Added enable_flag and disable_flag functions. Added enable_flag and disable_flag management commands. 5.0.2 \u00b6 What's new? \u00b6 Added defaults for FlaggedViewMixin 's kwargs (by @jackton1 ) 5.0.1 \u00b6 What's new? \u00b6 Added Django 3.1 support 5.0.0 \u00b6 What's new? \u00b6 Added Django 3.0 support Added validator support to ensure that the values that flag conditions test against are valid. Deprecations \u00b6 Deprecated the optional flags.middleware.FlagConditionsMiddleware in favor of always lazily caching flags on the request object. Removals \u00b6 Django Flags 4.1 deprecated support for using a single dictionary to hold key/values of conditions for a settings-based feature flag, and this has been removed. Use a list of dictionaries or tuples instead . Removed support for Django 1.11. 4.2.4 \u00b6 What's new? \u00b6 FLAGS_STATE_LOGGING is now False by default to cut down on potentially unwanted noise ( @darakian ). 4.2.3 \u00b6 What's new? \u00b6 Removed the word \"optional\" to describe non-required conditions in the Flag Conditions Debug Toolbar panel . 4.2.2 \u00b6 What's new? \u00b6 Fixed a bug where if a flag was defined in multiple sources the conditions defined in subsequent sources would not be evaluated. This means (with the default sources) if a flag is defined in Django settings and has conditions defined the database, only the settings conditions would be evaluated. 4.2.1 \u00b6 What's new? \u00b6 Made the language around optional boolean conditions with required conditions clearer in the Flag Conditions Debug Toolbar panel 4.2.0 \u00b6 What's new? \u00b6 Added optional Django Debug Toolbar panels to list all flag conditions and to report flag checks for a request . Added flag state check logging and FLAGS_STATE_LOGGING setting to enable it. Modified flag state checking to raise an AppRegistryNotReady if an attempt to check flag state is made before the app registry is ready. Modified flag view decorators to warn if a fallback view do not take the same arguments as the flag view. 4.1.2 \u00b6 What's new? \u00b6 Added support for Django 2.2 and Python 3.7 (Chris Adams). 4.1.1 \u00b6 What's new? \u00b6 boolean and anonymous conditions now accept multiple possible string representations of truth as their values. parameter conditions now accept possible parameter values . 4.1 \u00b6 What's new? \u00b6 Added the option to specifiy required conditions that must always be met. Deprecated support for using a single dictionary to hold key/values of conditions for a settings-based feature flag. Support will be removed in Django-Flags 5.0. Use a list of dictionaries or tuples instead . Added a before date condition that is met whenever the current date is before the expected date. 4.0.3 \u00b6 What's new? \u00b6 The system check introduced in 4.0.2 will no longer raise a ProgrammingError or an OperationalError when run pre-migration. 4.0.2 \u00b6 What's new? \u00b6 Logging of non-existent conditions is now a Django system check. 4.0.1 \u00b6 What's new? \u00b6 condition.check() returns a Falsy None instead of raising a TypeError when a configured condition has no function registered. 4.0 \u00b6 What's new? \u00b6 The template functions flag_enabled and flag_disabled in both Django and Jinja2 templates now support taking keyword arguments that could be used by custom conditions . Jinja2 template functions are now available via a Jinja2 extension that can be included in settings.py . The optional flags.middleware.FlagConditionsMiddleware has been added to ensure that all feature flag checks throughout single request cycle use the same flag conditions. Support for specifying the source of feature flags in settings.py has been added to allow further customization and the potential to limit flags to settings or database-only. The \"user\" condition now supports custom user models. ( @callorico ) Upgrading \u00b6 Django-Flags 4.0 introduces backwards-incompatible changes for users of Jinja2 templates. Previously Django-Flags provided flags.template_functions.flag_enabled and flags.template_functions.flag_disabled functions that had to be registered in the Jinja2 environment downstream. The Django-Flags documentation recommended doing so in jinja2.Environment.globals.update() . flags.template_functions has been removed in Django-Flags 4.0. Jinja2 function registration is now handled by a flags.jinja2tags.flags Jinja2 extension. To use Django-Flags 4.0 with Jinja2 templates, the TEMPLATES setting in settings.py should to be modified to include the extension: TEMPLATES = [ { 'BACKEND': 'django.template.backends.jinja2.Jinja2', ... 'OPTIONS': { 'extensions': [ ... 'flags.jinja2tags.flags', # add this line to your existing settings ... ], } }, ] 3.0.2 \u00b6 What's new? \u00b6 Requests are now optional the flag_enabled and flag_disabled template tags. Flag state form conditions are now bound when the form is created to ensure all custom conditions are available on the form. ( @callorico ) 3.0.1 \u00b6 What's new? \u00b6 Django 2.1 is now supported. 3.0 \u00b6 Django-Flags is a fork of the Django-only components of the Wagtail-Flags feature flag library. This is the initial release.","title":"Release notes"},{"location":"releasenotes/#release-notes","text":"","title":"Release Notes"},{"location":"releasenotes/#510","text":"","title":"5.1.0"},{"location":"releasenotes/#whats-new","text":"Added support for Python 3.13, removed support for Python < 3.10","title":"What's new?"},{"location":"releasenotes/#5014","text":"","title":"5.0.14"},{"location":"releasenotes/#whats-new_1","text":"Updated packaging to pyproject.toml and linting/formatting to ruff Added Django 5.0 support (thanks @adamchainz !) Added Django 5.2 support (thanks @sergei-maertens !)","title":"What's new?"},{"location":"releasenotes/#bug-fixes","text":"Fixed parameter condition example in docs (thanks @andy-isoc !)","title":"Bug fixes"},{"location":"releasenotes/#5013","text":"","title":"5.0.13"},{"location":"releasenotes/#whats-new_2","text":"Modernize code for Python 3.6+ (thanks @adamchainz !) Run linters with Python 3.11 (thanks @adamchainz !) Format with Black 23 (thanks @adamchainz !) Added Django 4.2 support (thanks @adamchainz !).","title":"What's new?"},{"location":"releasenotes/#removals","text":"Removed Python 3.6 support (thanks @michael-k !).","title":"Removals"},{"location":"releasenotes/#bug-fixes_1","text":"Removed errant print statement (thanks @Natim !).","title":"Bug fixes"},{"location":"releasenotes/#5012","text":"","title":"5.0.12"},{"location":"releasenotes/#whats-new_3","text":"Added Django 4.1 support (thanks @adamchainz !).","title":"What's new?"},{"location":"releasenotes/#5011","text":"","title":"5.0.11"},{"location":"releasenotes/#whats-new_4","text":"Added changelog and documentation links to the package on PyPI (thanks @adamchainz !)","title":"What's new?"},{"location":"releasenotes/#5010","text":"","title":"5.0.10"},{"location":"releasenotes/#whats-new_5","text":"Fixed an issue with resolving include() s in flagged_path() URL patterns ( #100 )","title":"What's new?"},{"location":"releasenotes/#509","text":"","title":"5.0.9"},{"location":"releasenotes/#whats-new_6","text":"Fixed a DeprecationWarning on Jinja 3+. Fixed an AttributeError on AnonymousUser in the user condition (thanks @edomora97 !)","title":"What's new?"},{"location":"releasenotes/#508","text":"","title":"5.0.8"},{"location":"releasenotes/#whats-new_7","text":"Prevent RemovedInDjango41Warning about default_app_config for Django 3.2+ (thanks @adamchainz !)","title":"What's new?"},{"location":"releasenotes/#507","text":"","title":"5.0.7"},{"location":"releasenotes/#whats-new_8","text":"Update Django 4 pin to allow versions under 4.1","title":"What's new?"},{"location":"releasenotes/#506","text":"","title":"5.0.6"},{"location":"releasenotes/#whats-new_9","text":"Added Django 4.0 support (thanks @gregtap !)","title":"What's new?"},{"location":"releasenotes/#505","text":"","title":"5.0.5"},{"location":"releasenotes/#whats-new_10","text":"Added Django 3.2 support (thanks @dduong42 !)","title":"What's new?"},{"location":"releasenotes/#504","text":"","title":"5.0.4"},{"location":"releasenotes/#whats-new_11","text":"Fixed the \"path matches\" condition validator to allow any valid regular expression.","title":"What's new?"},{"location":"releasenotes/#503","text":"","title":"5.0.3"},{"location":"releasenotes/#whats-new_12","text":"Added enable_flag and disable_flag functions. Added enable_flag and disable_flag management commands.","title":"What's new?"},{"location":"releasenotes/#502","text":"","title":"5.0.2"},{"location":"releasenotes/#whats-new_13","text":"Added defaults for FlaggedViewMixin 's kwargs (by @jackton1 )","title":"What's new?"},{"location":"releasenotes/#501","text":"","title":"5.0.1"},{"location":"releasenotes/#whats-new_14","text":"Added Django 3.1 support","title":"What's new?"},{"location":"releasenotes/#500","text":"","title":"5.0.0"},{"location":"releasenotes/#whats-new_15","text":"Added Django 3.0 support Added validator support to ensure that the values that flag conditions test against are valid.","title":"What's new?"},{"location":"releasenotes/#deprecations","text":"Deprecated the optional flags.middleware.FlagConditionsMiddleware in favor of always lazily caching flags on the request object.","title":"Deprecations"},{"location":"releasenotes/#removals_1","text":"Django Flags 4.1 deprecated support for using a single dictionary to hold key/values of conditions for a settings-based feature flag, and this has been removed. Use a list of dictionaries or tuples instead . Removed support for Django 1.11.","title":"Removals"},{"location":"releasenotes/#424","text":"","title":"4.2.4"},{"location":"releasenotes/#whats-new_16","text":"FLAGS_STATE_LOGGING is now False by default to cut down on potentially unwanted noise ( @darakian ).","title":"What's new?"},{"location":"releasenotes/#423","text":"","title":"4.2.3"},{"location":"releasenotes/#whats-new_17","text":"Removed the word \"optional\" to describe non-required conditions in the Flag Conditions Debug Toolbar panel .","title":"What's new?"},{"location":"releasenotes/#422","text":"","title":"4.2.2"},{"location":"releasenotes/#whats-new_18","text":"Fixed a bug where if a flag was defined in multiple sources the conditions defined in subsequent sources would not be evaluated. This means (with the default sources) if a flag is defined in Django settings and has conditions defined the database, only the settings conditions would be evaluated.","title":"What's new?"},{"location":"releasenotes/#421","text":"","title":"4.2.1"},{"location":"releasenotes/#whats-new_19","text":"Made the language around optional boolean conditions with required conditions clearer in the Flag Conditions Debug Toolbar panel","title":"What's new?"},{"location":"releasenotes/#420","text":"","title":"4.2.0"},{"location":"releasenotes/#whats-new_20","text":"Added optional Django Debug Toolbar panels to list all flag conditions and to report flag checks for a request . Added flag state check logging and FLAGS_STATE_LOGGING setting to enable it. Modified flag state checking to raise an AppRegistryNotReady if an attempt to check flag state is made before the app registry is ready. Modified flag view decorators to warn if a fallback view do not take the same arguments as the flag view.","title":"What's new?"},{"location":"releasenotes/#412","text":"","title":"4.1.2"},{"location":"releasenotes/#whats-new_21","text":"Added support for Django 2.2 and Python 3.7 (Chris Adams).","title":"What's new?"},{"location":"releasenotes/#411","text":"","title":"4.1.1"},{"location":"releasenotes/#whats-new_22","text":"boolean and anonymous conditions now accept multiple possible string representations of truth as their values. parameter conditions now accept possible parameter values .","title":"What's new?"},{"location":"releasenotes/#41","text":"","title":"4.1"},{"location":"releasenotes/#whats-new_23","text":"Added the option to specifiy required conditions that must always be met. Deprecated support for using a single dictionary to hold key/values of conditions for a settings-based feature flag. Support will be removed in Django-Flags 5.0. Use a list of dictionaries or tuples instead . Added a before date condition that is met whenever the current date is before the expected date.","title":"What's new?"},{"location":"releasenotes/#403","text":"","title":"4.0.3"},{"location":"releasenotes/#whats-new_24","text":"The system check introduced in 4.0.2 will no longer raise a ProgrammingError or an OperationalError when run pre-migration.","title":"What's new?"},{"location":"releasenotes/#402","text":"","title":"4.0.2"},{"location":"releasenotes/#whats-new_25","text":"Logging of non-existent conditions is now a Django system check.","title":"What's new?"},{"location":"releasenotes/#401","text":"","title":"4.0.1"},{"location":"releasenotes/#whats-new_26","text":"condition.check() returns a Falsy None instead of raising a TypeError when a configured condition has no function registered.","title":"What's new?"},{"location":"releasenotes/#40","text":"","title":"4.0"},{"location":"releasenotes/#whats-new_27","text":"The template functions flag_enabled and flag_disabled in both Django and Jinja2 templates now support taking keyword arguments that could be used by custom conditions . Jinja2 template functions are now available via a Jinja2 extension that can be included in settings.py . The optional flags.middleware.FlagConditionsMiddleware has been added to ensure that all feature flag checks throughout single request cycle use the same flag conditions. Support for specifying the source of feature flags in settings.py has been added to allow further customization and the potential to limit flags to settings or database-only. The \"user\" condition now supports custom user models. ( @callorico )","title":"What's new?"},{"location":"releasenotes/#upgrading","text":"Django-Flags 4.0 introduces backwards-incompatible changes for users of Jinja2 templates. Previously Django-Flags provided flags.template_functions.flag_enabled and flags.template_functions.flag_disabled functions that had to be registered in the Jinja2 environment downstream. The Django-Flags documentation recommended doing so in jinja2.Environment.globals.update() . flags.template_functions has been removed in Django-Flags 4.0. Jinja2 function registration is now handled by a flags.jinja2tags.flags Jinja2 extension. To use Django-Flags 4.0 with Jinja2 templates, the TEMPLATES setting in settings.py should to be modified to include the extension: TEMPLATES = [ { 'BACKEND': 'django.template.backends.jinja2.Jinja2', ... 'OPTIONS': { 'extensions': [ ... 'flags.jinja2tags.flags', # add this line to your existing settings ... ], } }, ]","title":"Upgrading"},{"location":"releasenotes/#302","text":"","title":"3.0.2"},{"location":"releasenotes/#whats-new_28","text":"Requests are now optional the flag_enabled and flag_disabled template tags. Flag state form conditions are now bound when the form is created to ensure all custom conditions are available on the form. ( @callorico )","title":"What's new?"},{"location":"releasenotes/#301","text":"","title":"3.0.1"},{"location":"releasenotes/#whats-new_29","text":"Django 2.1 is now supported.","title":"What's new?"},{"location":"releasenotes/#30","text":"Django-Flags is a fork of the Django-only components of the Wagtail-Flags feature flag library. This is the initial release.","title":"3.0"},{"location":"settings/","text":"Settings \u00b6 Defining flags \u00b6 FLAG_SOURCES \u00b6 Default: ('flags.sources.SettingsFlagsSource', 'flags.sources.DatabaseFlagsSource',) A list or tuple containing the full Python path strings to classes that provides a get_flags() method . The get_flags() method is expected to return a dictionary of flags and Condition objects . All flags returned by all flag sources will be available to check. FLAGS \u00b6 Default: {} A dictionary of feature flags and optional conditions used when 'flags.sources.SettingsFlagsSource' is in FLAG_SOURCES . Conditions can either be included as: A list of dictionaries with the format: {'condition': 'condition name', 'value': 'expected value', 'required': True}` or {'condition': 'condition name', 'value': 'expected value'} ( required defaults to False ). A list of 3-tuples with the format: (condition name, expected value, required) A list of 2-tuples with the format: (condition name, expected value) ( required defaults to False ) For example: FLAGS = { 'FLAG_WITH_EMPTY_CONDITIONS': [], 'FLAG_WITH_DICT_CONDITIONS': [ {'condition': 'condition name', 'value': 'expected value to be enabled'}, {'condition': 'condition name', 'value': 'expected value to be enabled', 'required': True}, ], 'FLAG_WITH_TUPLE_CONDITIONS': [ ('condition name', 'expected value to be enabled'), ('condition name', 'expected value to be enabled', True), ], # This is possible, but not recommended 'FLAG_WITH_MIXED_CONDITIONS': [ {'condition': 'condition name', 'value': 'expected value to be enabled'}, ('condition name', 'expected value to be enabled', True), ], } Previously flag definitions in FLAGS supported a single dictionary (rather than a list) with the condition name as the key and expected value as value. This method of specifying flags is deprecated and will be removed in Django-Flags 5.0. FLAGS_STATE_LOGGING \u00b6 Default: False If this setting is True Django-Flags will log all flag state checks with how the conditions were evaluated. These will appear in the log file like: INFO:flags.sources:Flag MY_FLAG evaluated False with conditions: boolean (False). INFO:flags.sources:Flag MY_FLAG evaluated True with conditions: boolean (False), path matches (True). This is intended for use in tracking the history and usage of enabled featured flags.","title":"Settings"},{"location":"settings/#settings","text":"","title":"Settings"},{"location":"settings/#defining-flags","text":"","title":"Defining flags"},{"location":"settings/#flag_sources","text":"Default: ('flags.sources.SettingsFlagsSource', 'flags.sources.DatabaseFlagsSource',) A list or tuple containing the full Python path strings to classes that provides a get_flags() method . The get_flags() method is expected to return a dictionary of flags and Condition objects . All flags returned by all flag sources will be available to check.","title":"FLAG_SOURCES"},{"location":"settings/#flags","text":"Default: {} A dictionary of feature flags and optional conditions used when 'flags.sources.SettingsFlagsSource' is in FLAG_SOURCES . Conditions can either be included as: A list of dictionaries with the format: {'condition': 'condition name', 'value': 'expected value', 'required': True}` or {'condition': 'condition name', 'value': 'expected value'} ( required defaults to False ). A list of 3-tuples with the format: (condition name, expected value, required) A list of 2-tuples with the format: (condition name, expected value) ( required defaults to False ) For example: FLAGS = { 'FLAG_WITH_EMPTY_CONDITIONS': [], 'FLAG_WITH_DICT_CONDITIONS': [ {'condition': 'condition name', 'value': 'expected value to be enabled'}, {'condition': 'condition name', 'value': 'expected value to be enabled', 'required': True}, ], 'FLAG_WITH_TUPLE_CONDITIONS': [ ('condition name', 'expected value to be enabled'), ('condition name', 'expected value to be enabled', True), ], # This is possible, but not recommended 'FLAG_WITH_MIXED_CONDITIONS': [ {'condition': 'condition name', 'value': 'expected value to be enabled'}, ('condition name', 'expected value to be enabled', True), ], } Previously flag definitions in FLAGS supported a single dictionary (rather than a list) with the condition name as the key and expected value as value. This method of specifying flags is deprecated and will be removed in Django-Flags 5.0.","title":"FLAGS"},{"location":"settings/#flags_state_logging","text":"Default: False If this setting is True Django-Flags will log all flag state checks with how the conditions were evaluated. These will appear in the log file like: INFO:flags.sources:Flag MY_FLAG evaluated False with conditions: boolean (False). INFO:flags.sources:Flag MY_FLAG evaluated True with conditions: boolean (False), path matches (True). This is intended for use in tracking the history and usage of enabled featured flags.","title":"FLAGS_STATE_LOGGING"},{"location":"testing/","text":"Testing \u00b6 Testing code that depends on flags \u00b6 Because FLAGS are definable in Django settings, you can use Django's standard override_settings to test with a flag off and on. from django.test import TestCase, override_settings class FlaggedCodeTestCase(TestCase): @override_settings(FLAGS={\"MY_FLAG\": [(\"boolean\", True)]}) def test_flag_enabled(self): # Do the thing that requires the flag to be enabled @override_settings(FLAGS={\"MY_FLAG\": [(\"boolean\", False)]}) def test_flag_disabled(self): # Do the thing that requires the flag to be disabled Alternatively, you can create a FlagState object along the same lines with a boolean condition that is True to test the flag-enabled code path, and then create one with a boolean condition that is False to test the not-enabled path. class FlaggedCodeTestCase(TestCase): def test_flag_enabled(self): FlagState.objects.create( name=\"MY_FLAG\", condition=\"boolean\", value=\"True\" ) # Do the thing that requires the flag to be enabled def test_flag_disabled(self): FlagState.objects.create( name=\"MY_FLAG\", condition=\"boolean\", value=\"True\" ) # Do the thing that requires the flag to be disabled","title":"Testing"},{"location":"testing/#testing","text":"","title":"Testing"},{"location":"testing/#testing-code-that-depends-on-flags","text":"Because FLAGS are definable in Django settings, you can use Django's standard override_settings to test with a flag off and on. from django.test import TestCase, override_settings class FlaggedCodeTestCase(TestCase): @override_settings(FLAGS={\"MY_FLAG\": [(\"boolean\", True)]}) def test_flag_enabled(self): # Do the thing that requires the flag to be enabled @override_settings(FLAGS={\"MY_FLAG\": [(\"boolean\", False)]}) def test_flag_disabled(self): # Do the thing that requires the flag to be disabled Alternatively, you can create a FlagState object along the same lines with a boolean condition that is True to test the flag-enabled code path, and then create one with a boolean condition that is False to test the not-enabled path. class FlaggedCodeTestCase(TestCase): def test_flag_enabled(self): FlagState.objects.create( name=\"MY_FLAG\", condition=\"boolean\", value=\"True\" ) # Do the thing that requires the flag to be enabled def test_flag_disabled(self): FlagState.objects.create( name=\"MY_FLAG\", condition=\"boolean\", value=\"True\" ) # Do the thing that requires the flag to be disabled","title":"Testing code that depends on flags"},{"location":"usage/","text":"Usage guide \u00b6 Defining flags \u00b6 Flags are defined in Django settings with the conditions in which they are enabled. FLAGS = { 'FLAG_WITH_EMPTY_CONDITIONS': [], 'FLAG_WITH_ANY_CONDITIONS': [ {'condition': 'condition name', 'value': 'expected value to be enabled'}, {'condition': 'user', 'value': 'lady.liberty'}, ], 'FLAG_WITH_REQUIRED_CONDITIONS': [ {'condition': 'user', 'value': 'lady.liberty'}, {'condition': 'path matches', 'value': r'^/liberty/island', 'required': True}, ] } The set of conditions can be empty (flag will never be enabled), have one or more conditions that are not required (any of those conditions can be met for the flag to be enabled), or one or more required conditions (all required conditions have to be met for the flag to be enabled). Additional conditions can be added in the Django admin for any defined flag (illustrated in Quickstart ). Conditions added in the Django admin can be changed without restarting Django, conditions defined in settings.py cannot. See the list of built-in conditions . Using flags in code \u00b6 Flags can be used in Python code: from flags.state import flag_enabled if flag_enabled('FLAG_WITH_ANY_CONDITIONS', request=a_request): print(\"My feature flag is enabled\") In Django templates: {% load feature_flags %} {% flag_enabled 'FLAG_WITH_ANY_CONDITIONS' as my_flag %} {% if my_flag %} <div> I\u2019m the result of a feature flag. </div> {% endif %} In Jinja2 templates (after adding flag_enabled to the Jinja2 environment ): {% if flag_enabled('FLAG_WITH_ANY_CONDITIONS', request) %} <div> I\u2019m the result of a feature flag. </div> {% endif %} In urls.py : from flags.urls import flagged_path urlpatterns = [ flagged_path('FLAG_WITH_REQUIRED_CONDITIONS', 'a-url/', view_requiring_flag, state=True), ] Testing with flags \u00b6 A test case that covers both values of the flag may look like this: from django.test import TestCase, override_settings class FlaggedCodeTestCase(TestCase): @override_settings(FLAGS={\"MY_FLAG\": [(\"boolean\", True)]}) def test_flag_enabled(self): # Do the thing that requires the flag to be enabled @override_settings(FLAGS={\"MY_FLAG\": [(\"boolean\", False)]}) def test_flag_disabled(self): # Do the thing that requires the flag to be disabled See the API reference for more details and examples.","title":"Usage guide"},{"location":"usage/#usage-guide","text":"","title":"Usage guide"},{"location":"usage/#defining-flags","text":"Flags are defined in Django settings with the conditions in which they are enabled. FLAGS = { 'FLAG_WITH_EMPTY_CONDITIONS': [], 'FLAG_WITH_ANY_CONDITIONS': [ {'condition': 'condition name', 'value': 'expected value to be enabled'}, {'condition': 'user', 'value': 'lady.liberty'}, ], 'FLAG_WITH_REQUIRED_CONDITIONS': [ {'condition': 'user', 'value': 'lady.liberty'}, {'condition': 'path matches', 'value': r'^/liberty/island', 'required': True}, ] } The set of conditions can be empty (flag will never be enabled), have one or more conditions that are not required (any of those conditions can be met for the flag to be enabled), or one or more required conditions (all required conditions have to be met for the flag to be enabled). Additional conditions can be added in the Django admin for any defined flag (illustrated in Quickstart ). Conditions added in the Django admin can be changed without restarting Django, conditions defined in settings.py cannot. See the list of built-in conditions .","title":"Defining flags"},{"location":"usage/#using-flags-in-code","text":"Flags can be used in Python code: from flags.state import flag_enabled if flag_enabled('FLAG_WITH_ANY_CONDITIONS', request=a_request): print(\"My feature flag is enabled\") In Django templates: {% load feature_flags %} {% flag_enabled 'FLAG_WITH_ANY_CONDITIONS' as my_flag %} {% if my_flag %} <div> I\u2019m the result of a feature flag. </div> {% endif %} In Jinja2 templates (after adding flag_enabled to the Jinja2 environment ): {% if flag_enabled('FLAG_WITH_ANY_CONDITIONS', request) %} <div> I\u2019m the result of a feature flag. </div> {% endif %} In urls.py : from flags.urls import flagged_path urlpatterns = [ flagged_path('FLAG_WITH_REQUIRED_CONDITIONS', 'a-url/', view_requiring_flag, state=True), ]","title":"Using flags in code"},{"location":"usage/#testing-with-flags","text":"A test case that covers both values of the flag may look like this: from django.test import TestCase, override_settings class FlaggedCodeTestCase(TestCase): @override_settings(FLAGS={\"MY_FLAG\": [(\"boolean\", True)]}) def test_flag_enabled(self): # Do the thing that requires the flag to be enabled @override_settings(FLAGS={\"MY_FLAG\": [(\"boolean\", False)]}) def test_flag_disabled(self): # Do the thing that requires the flag to be disabled See the API reference for more details and examples.","title":"Testing with flags"},{"location":"api/conditions/","text":"Conditions \u00b6 Conditions are functions that take a configured value and possible keyword arguments and determines whether the given arguments are equivalent to the value. Conditions are registered with a unique name that is exposed to users in Django settings and the Django admin. from flags import conditions Registering conditions \u00b6 conditions.register(condition_name, fn=None, validator=None) \u00b6 Register a new condition, either as a decorator: from flags import conditions @conditions.register('path') def path_condition(path, request=None, **kwargs): return request.path.startswith(path) Or as a function call: def path_condition(path, request=None, **kwargs): return request.path.startswith(path) conditions.register('path', fn=path_condition) Will raise a conditions.DuplicateCondition exception if the condition name is already registered. A validator can be given to validate the condition's expected value as provided by the flag sources , either as another callable as an argument to the register function: from django.core.exceptions import ValidationError from flags import conditions def validate_path(value): if not value.startswith('/'): raise ValidationError('Enter a valid path') @conditions.register('path', validator=validate_path) def path_condition(path, request=None, **kwargs): return request.path.startswith(path) Or as an attribute on the condition callable: from django.core.exceptions import ValidationError from flags import conditions class PathCondition: def __call__(self, path, request=None, **kwargs): return request.path.startswith(path) def validate(self, value): if not value.startswith('/'): raise ValidationError('Enter a valid path') conditions.register('path', fn=PathCondition) Validators specified in both ways are available on condition callables as a validate attribute: condition = get_condition('path') condition.validate(value) Exceptions \u00b6 conditions.DuplicateCondition \u00b6 Exception raised by conditions.register if the condition name being registered is already registered. conditions.RequiredForCondition \u00b6 Exception intended to be raised when a condition is not given a keyword argument it requires for evaluation. @conditions.register('path') def path_condition(path, request=None, **kwargs): if request is None: raise conditions.RequiredForCondition( \"request is required for condition 'path'\") return request.path.startswith(path)","title":"Conditions"},{"location":"api/conditions/#conditions","text":"Conditions are functions that take a configured value and possible keyword arguments and determines whether the given arguments are equivalent to the value. Conditions are registered with a unique name that is exposed to users in Django settings and the Django admin. from flags import conditions","title":"Conditions"},{"location":"api/conditions/#registering-conditions","text":"","title":"Registering conditions"},{"location":"api/conditions/#conditionsregistercondition_name-fnnone-validatornone","text":"Register a new condition, either as a decorator: from flags import conditions @conditions.register('path') def path_condition(path, request=None, **kwargs): return request.path.startswith(path) Or as a function call: def path_condition(path, request=None, **kwargs): return request.path.startswith(path) conditions.register('path', fn=path_condition) Will raise a conditions.DuplicateCondition exception if the condition name is already registered. A validator can be given to validate the condition's expected value as provided by the flag sources , either as another callable as an argument to the register function: from django.core.exceptions import ValidationError from flags import conditions def validate_path(value): if not value.startswith('/'): raise ValidationError('Enter a valid path') @conditions.register('path', validator=validate_path) def path_condition(path, request=None, **kwargs): return request.path.startswith(path) Or as an attribute on the condition callable: from django.core.exceptions import ValidationError from flags import conditions class PathCondition: def __call__(self, path, request=None, **kwargs): return request.path.startswith(path) def validate(self, value): if not value.startswith('/'): raise ValidationError('Enter a valid path') conditions.register('path', fn=PathCondition) Validators specified in both ways are available on condition callables as a validate attribute: condition = get_condition('path') condition.validate(value)","title":"conditions.register(condition_name, fn=None, validator=None)"},{"location":"api/conditions/#exceptions","text":"","title":"Exceptions"},{"location":"api/conditions/#conditionsduplicatecondition","text":"Exception raised by conditions.register if the condition name being registered is already registered.","title":"conditions.DuplicateCondition"},{"location":"api/conditions/#conditionsrequiredforcondition","text":"Exception intended to be raised when a condition is not given a keyword argument it requires for evaluation. @conditions.register('path') def path_condition(path, request=None, **kwargs): if request is None: raise conditions.RequiredForCondition( \"request is required for condition 'path'\") return request.path.startswith(path)","title":"conditions.RequiredForCondition"},{"location":"api/decorators/","text":"Flag decorators \u00b6 Decorators are provided for use with Django views and conditions that take a request argument. The default behavior is to return a 404 if a callable fallback is not given. from flags.decorators import ( flag_check, flag_required, ) Checking state \u00b6 flag_check(flag_name, state, fallback=None, **kwargs) \u00b6 Check that a given flag has the given state. If the state does not match, perform the fallback. Note Because flags that do not exist are taken to be False by default, @flag_check('MY_FLAG', False) and @flag_check('MY_FLAG', None) will both succeed if MY_FLAG does not exist. Note When a fallback view is given it must take the same arguments as the decorated view. from flags.decorators import flag_check @flag_check('MY_FLAG', True) def view_requiring_flag(request): return HttpResponse('MY_FLAG was true') @flag_check('MY_OTHER_FLAG', False) def view_requiring_other_flag_not_true(request): return HttpResponse('MY_OTHER_FLAG was False') def fallback_view(request): return HttpResponse('MY_FLAG_WITH_FALLBACK was False') @flag_check('MY_FLAG_WITH_FALLBACK', True, fallback=fallback_view) def view_with_fallback(request): return HttpResponse('MY_FLAG_WITH_FALLBACK was True') Requiring state \u00b6 flag_required(flag_name, fallback_view=None, pass_if_set=True) \u00b6 Require the given flag to be enabled. Note When a fallback view is given it must take the same arguments as the decorated view. from flags.decorators import flag_required @flag_required('MY_FLAG') def view_requiring_flag(request): return HttpResponse('flag was set') def other_view(request): return HttpResponse('flag was not set') @flag_required('MY_FLAG_WITH_FALLBACK', fallback_view=other_view) def view_with_fallback(request): return HttpResponse('flag was set')","title":"Flag decorators"},{"location":"api/decorators/#flag-decorators","text":"Decorators are provided for use with Django views and conditions that take a request argument. The default behavior is to return a 404 if a callable fallback is not given. from flags.decorators import ( flag_check, flag_required, )","title":"Flag decorators"},{"location":"api/decorators/#checking-state","text":"","title":"Checking state"},{"location":"api/decorators/#flag_checkflag_name-state-fallbacknone-kwargs","text":"Check that a given flag has the given state. If the state does not match, perform the fallback. Note Because flags that do not exist are taken to be False by default, @flag_check('MY_FLAG', False) and @flag_check('MY_FLAG', None) will both succeed if MY_FLAG does not exist. Note When a fallback view is given it must take the same arguments as the decorated view. from flags.decorators import flag_check @flag_check('MY_FLAG', True) def view_requiring_flag(request): return HttpResponse('MY_FLAG was true') @flag_check('MY_OTHER_FLAG', False) def view_requiring_other_flag_not_true(request): return HttpResponse('MY_OTHER_FLAG was False') def fallback_view(request): return HttpResponse('MY_FLAG_WITH_FALLBACK was False') @flag_check('MY_FLAG_WITH_FALLBACK', True, fallback=fallback_view) def view_with_fallback(request): return HttpResponse('MY_FLAG_WITH_FALLBACK was True')","title":"flag_check(flag_name, state, fallback=None, **kwargs)"},{"location":"api/decorators/#requiring-state","text":"","title":"Requiring state"},{"location":"api/decorators/#flag_requiredflag_name-fallback_viewnone-pass_if_settrue","text":"Require the given flag to be enabled. Note When a fallback view is given it must take the same arguments as the decorated view. from flags.decorators import flag_required @flag_required('MY_FLAG') def view_requiring_flag(request): return HttpResponse('flag was set') def other_view(request): return HttpResponse('flag was not set') @flag_required('MY_FLAG_WITH_FALLBACK', fallback_view=other_view) def view_with_fallback(request): return HttpResponse('flag was set')","title":"flag_required(flag_name, fallback_view=None, pass_if_set=True)"},{"location":"api/django/","text":"Django templates \u00b6 Django-Flags provides a template tag library that can be used to evaluate flags in Django templates. {% load feature_flags %} Checking state \u00b6 flag_enabled \u00b6 Returns True if a flag is enabled, otherwise returns False . {% flag_enabled 'MY_FLAG' as my_flag %} {% if my_flag %} <div class=\"m-global-banner\"> I\u2019m the result of a feature flag. </div> {% endif %} flag_disabled \u00b6 Returns True if a flag is disabled, otherwise returns False . {% flag_disabled 'MY_FLAG' as my_flag %} {% if my_flag %} <div class=\"m-global-banner\"> I\u2019m the result of a feature flag that is not enabled. </div> {% endif %} If a request exists in the current context, it will be passed to any conditions that use it. Passing additional arguments \u00b6 Some conditions take additional keyword arguments. For example, you could pass a page object: {% flag_enabled 'MY_FLAG_THAT_CHECKS_PAGE' page=page as my_flag %} {% if my_flag %} This flag with a condition that uses the page object evaluated to True. {% endif %}","title":"Django templates"},{"location":"api/django/#django-templates","text":"Django-Flags provides a template tag library that can be used to evaluate flags in Django templates. {% load feature_flags %}","title":"Django templates"},{"location":"api/django/#checking-state","text":"","title":"Checking state"},{"location":"api/django/#flag_enabled","text":"Returns True if a flag is enabled, otherwise returns False . {% flag_enabled 'MY_FLAG' as my_flag %} {% if my_flag %} <div class=\"m-global-banner\"> I\u2019m the result of a feature flag. </div> {% endif %}","title":"flag_enabled"},{"location":"api/django/#flag_disabled","text":"Returns True if a flag is disabled, otherwise returns False . {% flag_disabled 'MY_FLAG' as my_flag %} {% if my_flag %} <div class=\"m-global-banner\"> I\u2019m the result of a feature flag that is not enabled. </div> {% endif %} If a request exists in the current context, it will be passed to any conditions that use it.","title":"flag_disabled"},{"location":"api/django/#passing-additional-arguments","text":"Some conditions take additional keyword arguments. For example, you could pass a page object: {% flag_enabled 'MY_FLAG_THAT_CHECKS_PAGE' page=page as my_flag %} {% if my_flag %} This flag with a condition that uses the page object evaluated to True. {% endif %}","title":"Passing additional arguments"},{"location":"api/jinja2/","text":"Jinja2 templates \u00b6 Django-Flags provides an extension for adding the template tags to your Jinja2 backend configuration to enable the tags to be used in Jinja2 templates. TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', ... }, { 'BACKEND': 'django.template.backends.jinja2.Jinja2', ... 'OPTIONS': { 'extensions': [ ... 'flags.jinja2tags.flags', # add this line to your existing settings ... ], } }, ] Checking state \u00b6 flag_enabled \u00b6 Returns True if a flag is enabled, otherwise returns False . {% if flag_enabled('MY_FLAG') %} <div class=\"m-global-banner\"> I\u2019m the result of a feature flag. </div> {% endif %} flag_disabled \u00b6 Returns True if a flag is disabled to its conditions, otherwise returns False . {% if flag_disabled('MY_FLAG') %} <div class=\"m-global-banner\"> I\u2019m the result of a feature flag that is not enabled. </div> {% endif %} If a request exists in the current context, it will be passed to any conditions that use it. Passing additional arguments \u00b6 Some conditions take additional keyword arguments. For example, you could pass a page object: {% if flag_enabled('MY_FLAG_THAT_CHECKS_PAGE', page=page) %} This flag with a condition that uses the page object evaluated to True. {% endif %}","title":"Jinja2 templates"},{"location":"api/jinja2/#jinja2-templates","text":"Django-Flags provides an extension for adding the template tags to your Jinja2 backend configuration to enable the tags to be used in Jinja2 templates. TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', ... }, { 'BACKEND': 'django.template.backends.jinja2.Jinja2', ... 'OPTIONS': { 'extensions': [ ... 'flags.jinja2tags.flags', # add this line to your existing settings ... ], } }, ]","title":"Jinja2 templates"},{"location":"api/jinja2/#checking-state","text":"","title":"Checking state"},{"location":"api/jinja2/#flag_enabled","text":"Returns True if a flag is enabled, otherwise returns False . {% if flag_enabled('MY_FLAG') %} <div class=\"m-global-banner\"> I\u2019m the result of a feature flag. </div> {% endif %}","title":"flag_enabled"},{"location":"api/jinja2/#flag_disabled","text":"Returns True if a flag is disabled to its conditions, otherwise returns False . {% if flag_disabled('MY_FLAG') %} <div class=\"m-global-banner\"> I\u2019m the result of a feature flag that is not enabled. </div> {% endif %} If a request exists in the current context, it will be passed to any conditions that use it.","title":"flag_disabled"},{"location":"api/jinja2/#passing-additional-arguments","text":"Some conditions take additional keyword arguments. For example, you could pass a page object: {% if flag_enabled('MY_FLAG_THAT_CHECKS_PAGE', page=page) %} This flag with a condition that uses the page object evaluated to True. {% endif %}","title":"Passing additional arguments"},{"location":"api/sources/","text":"Flag Sources \u00b6 Django-Flags provides a means to provide custom flag sources using the FLAG_SOURCES setting . Flag sources are classes that provide a get_flags method. The get_flags method must return a dictionary of flag name keys with a list of Condition objects. from flags.sources import Condition class CustomFlagSource(object): def get_flags(self): flags = { 'MY_FLAG': [ Condition('parameter', 'enable_my_flag'), ] } return flags API \u00b6 get_flags(sources=None, ignore_errors=False) \u00b6 Return a dictionary of all flag names with Flag objects that are available in the given sources . If sources is not given, the sources in the FLAG_SOURCES setting are used. If ignore_errors is True , any exceptions that occur when getting flags from a source will be caught and ignored. Condition(condition, value, required=False) \u00b6 A simple wrapper around conditions. Condition.check(*kwargs) \u00b6 Check the condition against the given keyword arguments. Flag(name, conditions=[]) \u00b6 A simple wrapper around flags and their conditions. conditions is a list of Condition objects. Flag.check_state(*kwargs) \u00b6 Check all of a flag's conditions and return the state based on the given keyword arguments.","title":"Flag sources"},{"location":"api/sources/#flag-sources","text":"Django-Flags provides a means to provide custom flag sources using the FLAG_SOURCES setting . Flag sources are classes that provide a get_flags method. The get_flags method must return a dictionary of flag name keys with a list of Condition objects. from flags.sources import Condition class CustomFlagSource(object): def get_flags(self): flags = { 'MY_FLAG': [ Condition('parameter', 'enable_my_flag'), ] } return flags","title":"Flag Sources"},{"location":"api/sources/#api","text":"","title":"API"},{"location":"api/sources/#get_flagssourcesnone-ignore_errorsfalse","text":"Return a dictionary of all flag names with Flag objects that are available in the given sources . If sources is not given, the sources in the FLAG_SOURCES setting are used. If ignore_errors is True , any exceptions that occur when getting flags from a source will be caught and ignored.","title":"get_flags(sources=None, ignore_errors=False)"},{"location":"api/sources/#conditioncondition-value-requiredfalse","text":"A simple wrapper around conditions.","title":"Condition(condition, value, required=False)"},{"location":"api/sources/#conditioncheckkwargs","text":"Check the condition against the given keyword arguments.","title":"Condition.check(*kwargs)"},{"location":"api/sources/#flagname-conditions","text":"A simple wrapper around flags and their conditions. conditions is a list of Condition objects.","title":"Flag(name, conditions=[])"},{"location":"api/sources/#flagcheck_statekwargs","text":"Check all of a flag's conditions and return the state based on the given keyword arguments.","title":"Flag.check_state(*kwargs)"},{"location":"api/state/","text":"Flag state \u00b6 from flags.state import ( flag_state, flag_enabled, flag_disabled, enable_flag, disable_flag, ) Note If any of the flag state checking functions below is used at the top-level of a module (in urls.py , for example), it will be evaluated at import-time. This may have unintended consequences. Database flag conditions may not be available, custom conditions may not be registered, and any dynamic change in flag state (such as date-based conditions or a newly added database condition) will not have an effect. Consider using the flagged URLs API for state-checking in urls.py , the view decorators and the class-based view mixin for state-checking Django views, and using the state checking functions below inside methods and functions. This will have the added benefit of ensuring that the intention is clear, and that flagged code is as tightly-scoped as possible. Checking state \u00b6 flag_state(flag_name, **kwargs) \u00b6 Return the value for the flag ( True or False ) by passing kwargs to its conditions. If the flag does not exist, this will return None so that existence can be introspected but will still evaluate to False . Requiring state \u00b6 flag_enabled(flag_name, **kwargs) \u00b6 Returns True if a flag is enabled by passing kwargs to its conditions, otherwise returns False . if flag_enabled('MY_FLAG', request=a_request): print(\"My feature flag is enabled\") flag_disabled(flag_name, **kwargs) \u00b6 Returns True if a flag is disabled by passing kwargs to its conditions, otherwise returns False . if flag_disabled('MY_FLAG', request=a_request): print(\u201cMy feature flag is disabled\u201d) Setting state \u00b6 enable_flag(flag_name, create_boolean_condition=True, request=None) \u00b6 Enable a flag by adding or setting an existing database boolean condition to True . If the flag has other required conditions, those will take precedence. If create_boolean_condition is False , and a boolean database condition does not already exist, a ValueError will be raised. disable_flag(flag_name, create_boolean_condition=True, request=None) \u00b6 Disable a flag by adding or setting an existing database boolean condition to False . If the flag has other required conditions, those will take precedence. If create_boolean_condition is False , and a boolean database condition does not already exist, a ValueError will be raised.","title":"Flag state"},{"location":"api/state/#flag-state","text":"from flags.state import ( flag_state, flag_enabled, flag_disabled, enable_flag, disable_flag, ) Note If any of the flag state checking functions below is used at the top-level of a module (in urls.py , for example), it will be evaluated at import-time. This may have unintended consequences. Database flag conditions may not be available, custom conditions may not be registered, and any dynamic change in flag state (such as date-based conditions or a newly added database condition) will not have an effect. Consider using the flagged URLs API for state-checking in urls.py , the view decorators and the class-based view mixin for state-checking Django views, and using the state checking functions below inside methods and functions. This will have the added benefit of ensuring that the intention is clear, and that flagged code is as tightly-scoped as possible.","title":"Flag state"},{"location":"api/state/#checking-state","text":"","title":"Checking state"},{"location":"api/state/#flag_stateflag_name-kwargs","text":"Return the value for the flag ( True or False ) by passing kwargs to its conditions. If the flag does not exist, this will return None so that existence can be introspected but will still evaluate to False .","title":"flag_state(flag_name, **kwargs)"},{"location":"api/state/#requiring-state","text":"","title":"Requiring state"},{"location":"api/state/#flag_enabledflag_name-kwargs","text":"Returns True if a flag is enabled by passing kwargs to its conditions, otherwise returns False . if flag_enabled('MY_FLAG', request=a_request): print(\"My feature flag is enabled\")","title":"flag_enabled(flag_name, **kwargs)"},{"location":"api/state/#flag_disabledflag_name-kwargs","text":"Returns True if a flag is disabled by passing kwargs to its conditions, otherwise returns False . if flag_disabled('MY_FLAG', request=a_request): print(\u201cMy feature flag is disabled\u201d)","title":"flag_disabled(flag_name, **kwargs)"},{"location":"api/state/#setting-state","text":"","title":"Setting state"},{"location":"api/state/#enable_flagflag_name-create_boolean_conditiontrue-requestnone","text":"Enable a flag by adding or setting an existing database boolean condition to True . If the flag has other required conditions, those will take precedence. If create_boolean_condition is False , and a boolean database condition does not already exist, a ValueError will be raised.","title":"enable_flag(flag_name, create_boolean_condition=True, request=None)"},{"location":"api/state/#disable_flagflag_name-create_boolean_conditiontrue-requestnone","text":"Disable a flag by adding or setting an existing database boolean condition to False . If the flag has other required conditions, those will take precedence. If create_boolean_condition is False , and a boolean database condition does not already exist, a ValueError will be raised.","title":"disable_flag(flag_name, create_boolean_condition=True, request=None)"},{"location":"api/urls/","text":"Flagged URL patterns \u00b6 Flagged URL patterns are an alternative to flagging views with decorators . from flags.urls import flagged_path, flagged_paths, flagged_re_path, flagged_re_paths flagged_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None) \u00b6 flagged_re_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None) \u00b6 Make a URL depend on the state of a feature flag. flagged_path() can be used in place of Django's path() . flagged_re_path() can be used in place of Django's re_path() . The view and the fallback can both be a set of include() ed patterns but any matching URL patterns in the includes must match exactly in terms of regular expression, keyword arguments, and name, otherwise a 404 may be unexpectedly raised. If a fallback is not given the flagged url will raise a 404 if the flag state does not match the required state . Note When a fallback view is given it must take the same arguments as the flagged view. urlpatterns = [ flagged_path('MY_FLAG', 'a-url/', view_requiring_flag, state=True), flagged_re_path('MY_FLAG_WITH_FALLBACK', r'^another-url$', view_with_fallback, state=True, fallback=other_view) flagged_path('MY_FLAGGED_INCLUDE', 'myapp/', include('myapp.urls'), state=True, fallback=other_view) flagged_re_path('MY_NEW_APP_FLAG', r'^mynewapp$', include('mynewapp.urls'), state=True, fallback=include('myoldapp.urls')) ] flagged_paths(flag_name, state=True, fallback=None) \u00b6 flagged_re_paths(flag_name, state=True, fallback=None) \u00b6 Flag multiple URLs in the same context with a context manager. flagged_paths() returns a function that takes the same arguments as Django's path() and which will flag the pattern's view. flagged_re_paths() returns a function that takes the same arguments as Django's re_path() and which will flag the pattern's view. Note When a fallback view is given it must take the same arguments as the flagged view. with flagged_paths('MY_FLAG') as path: flagged_url_patterns = [ path('a-url/', view_requiring_flag), ] urlpatterns = urlpatterns + flagged_url_patterns","title":"Flagged URL patterns"},{"location":"api/urls/#flagged-url-patterns","text":"Flagged URL patterns are an alternative to flagging views with decorators . from flags.urls import flagged_path, flagged_paths, flagged_re_path, flagged_re_paths","title":"Flagged URL patterns"},{"location":"api/urls/#flagged_pathflag_name-route-view-kwargsnone-namenone-statetrue-fallbacknone","text":"","title":"flagged_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None)"},{"location":"api/urls/#flagged_re_pathflag_name-route-view-kwargsnone-namenone-statetrue-fallbacknone","text":"Make a URL depend on the state of a feature flag. flagged_path() can be used in place of Django's path() . flagged_re_path() can be used in place of Django's re_path() . The view and the fallback can both be a set of include() ed patterns but any matching URL patterns in the includes must match exactly in terms of regular expression, keyword arguments, and name, otherwise a 404 may be unexpectedly raised. If a fallback is not given the flagged url will raise a 404 if the flag state does not match the required state . Note When a fallback view is given it must take the same arguments as the flagged view. urlpatterns = [ flagged_path('MY_FLAG', 'a-url/', view_requiring_flag, state=True), flagged_re_path('MY_FLAG_WITH_FALLBACK', r'^another-url$', view_with_fallback, state=True, fallback=other_view) flagged_path('MY_FLAGGED_INCLUDE', 'myapp/', include('myapp.urls'), state=True, fallback=other_view) flagged_re_path('MY_NEW_APP_FLAG', r'^mynewapp$', include('mynewapp.urls'), state=True, fallback=include('myoldapp.urls')) ]","title":"flagged_re_path(flag_name, route, view, kwargs=None, name=None, state=True, fallback=None)"},{"location":"api/urls/#flagged_pathsflag_name-statetrue-fallbacknone","text":"","title":"flagged_paths(flag_name, state=True, fallback=None)"},{"location":"api/urls/#flagged_re_pathsflag_name-statetrue-fallbacknone","text":"Flag multiple URLs in the same context with a context manager. flagged_paths() returns a function that takes the same arguments as Django's path() and which will flag the pattern's view. flagged_re_paths() returns a function that takes the same arguments as Django's re_path() and which will flag the pattern's view. Note When a fallback view is given it must take the same arguments as the flagged view. with flagged_paths('MY_FLAG') as path: flagged_url_patterns = [ path('a-url/', view_requiring_flag), ] urlpatterns = urlpatterns + flagged_url_patterns","title":"flagged_re_paths(flag_name, state=True, fallback=None)"},{"location":"api/views/","text":"Class-based views \u00b6 from flags.views import ( FlaggedViewMixin, FlaggedTemplateView, ) API \u00b6 FlaggedViewMixin \u00b6 Adds flag-checking to HTTP method dispatching in class-based views . Attributes \u00b6 `flag_name` The feature flag this view depends on. `state` Either `True` or `False`, the state the feature flag should be in. By default, `state` is `True`, requiring the flag to evaluate to `True`. `fallback` A view to fallback on if the flag does not match the required `state`. Defaults to `None`, causing the view to raise a `404` if the flag does not match the required `state`. Note When a fallback view is given it must take the same arguments as the flagged view. For example, in views.py : from django.views.generic import View from flags.views import FlaggedViewMixin class MyFlaggedView(FlaggedViewMixin, View): def get(self, request, *args, **kwargs): return HttpResponse('ok') And in urls.py : from django.urls import path from flags.urls import flagged_path urlpatterns = [ path('my-url/', MyFlaggedView.as_view(flag_name='MY_FLAG')) ] FlaggedTemplateView \u00b6 A combination of TemplateView and FlaggedViewMixin . For example, in views.py : from flags.views import FlaggedTemplateView class MyFlaggedView(FlaggedTemplateView): template_name = \"mytemplate.html\" flag_name = 'MY_FLAG' Or to serve a template directly in urls.py : from django.urls import path from flags.views import FlaggedTemplateView urlpatterns = [ path( 'my_url/', FlaggedTemplateView.as_view( template_name='mytemplate.html', flag_name='MY_FLAG' ) ), ]","title":"Class-based views"},{"location":"api/views/#class-based-views","text":"from flags.views import ( FlaggedViewMixin, FlaggedTemplateView, )","title":"Class-based views"},{"location":"api/views/#api","text":"","title":"API"},{"location":"api/views/#flaggedviewmixin","text":"Adds flag-checking to HTTP method dispatching in class-based views .","title":"FlaggedViewMixin"},{"location":"api/views/#attributes","text":"`flag_name` The feature flag this view depends on. `state` Either `True` or `False`, the state the feature flag should be in. By default, `state` is `True`, requiring the flag to evaluate to `True`. `fallback` A view to fallback on if the flag does not match the required `state`. Defaults to `None`, causing the view to raise a `404` if the flag does not match the required `state`. Note When a fallback view is given it must take the same arguments as the flagged view. For example, in views.py : from django.views.generic import View from flags.views import FlaggedViewMixin class MyFlaggedView(FlaggedViewMixin, View): def get(self, request, *args, **kwargs): return HttpResponse('ok') And in urls.py : from django.urls import path from flags.urls import flagged_path urlpatterns = [ path('my-url/', MyFlaggedView.as_view(flag_name='MY_FLAG')) ]","title":"Attributes"},{"location":"api/views/#flaggedtemplateview","text":"A combination of TemplateView and FlaggedViewMixin . For example, in views.py : from flags.views import FlaggedTemplateView class MyFlaggedView(FlaggedTemplateView): template_name = \"mytemplate.html\" flag_name = 'MY_FLAG' Or to serve a template directly in urls.py : from django.urls import path from flags.views import FlaggedTemplateView urlpatterns = [ path( 'my_url/', FlaggedTemplateView.as_view( template_name='mytemplate.html', flag_name='MY_FLAG' ) ), ]","title":"FlaggedTemplateView"}]}